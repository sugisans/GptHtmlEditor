<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GPT HTML/CSS Editor</title>
  <style>
    :root{--gap:10px;--pane-bg:#0f172a;--panel-bg:#0b1220;--muted:#bfc8d9}
    html,body{height:100%;margin:0;;background:#0b1220;font-family:Inter,ui-sans-serif,system-ui,Helvetica,Arial}
    .app{display:grid;grid-template-columns:1fr 520px;gap:var(--gap);height:100vh;padding:12px;color:white}
    .left{display:flex;flex-direction:column;gap:10px}
    .editors{display:flex;gap:8px}
    textarea{width:100%;min-height:500px;resize:both;background:var(--panel-bg);border:1px solid rgba(255,255,255,0.06);color:#e6eef8;padding:10px;border-radius:8px;font-family:Menlo,monospace;font-size:13px}
    .tabs{display:flex;gap:6px}
    .tab{padding:6px 10px;background:#071127;border-radius:6px;cursor:pointer;color:var(--muted)}
    .tab:hover{color:#e6eef8}
    .tab.active{background:#0d1a2b;color:white}
    .controls{display:flex;gap:8px;align-items:center}
    button{background:#062037;color:white;border:1px solid rgba(255,255,255,0.06);padding:8px 10px;border-radius:8px;cursor:pointer}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06)}
    .right{display:flex;flex-direction:column;gap:8px}
    .iframe-wrap{flex:1;border-radius:8px;overflow:hidden;border:1px solid rgba(255,255,255,0.06)}
    iframe{width:100%;height:100%;border:0;background:white}
    .save-list{max-height:140px;overflow:auto;background:#071127;padding:8px;border-radius:8px}
    .save-item{display:flex;justify-content:space-between;padding:6px;border-radius:6px}
    .note{color:var(--muted);font-size:13px}
    .row{display:flex;gap:8px;align-items:center}
    input[type=text]{padding:6px;border-radius:6px;border:1px solid rgba(255,255,255,0.06);background:#071127;color:white}
    #openNewTab{flex:1}
    
    .fullscreen-editor {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #0b1220;
      z-index: 9999;
      display: flex;
      flex-direction: column;
      padding: 10px;
      box-sizing: border-box;
    }

    .fullscreen-editor textarea {
      flex: 1;
      width: 100%;
      height: 100%;
      resize: none;
      background: #111a2c;
      color: white;
      border: none;
      outline: none;
      border-radius: 8px;
      font-family: Menlo, monospace;
      font-size: 14px;
      padding: 10px;
    }

    .fullscreen-editor button.close-btn {
      align-self: flex-end;
      margin-bottom: 10px;
      padding: 6px 12px;
      background: #1e293b;
      border: 1px solid #334155;
      border-radius: 6px;
      color: white;
      cursor: pointer;
    }

    #sandboxContainer {
      position: fixed;
      inset: 0;
      background: #0f172a;
      display: flex;
      flex-direction: column;
      z-index: 9999;
    }

    #sandboxContainer.hidden {
      display: none;
    }

    .sandbox-header {
      display: flex;
      justify-content: flex-end;
      padding: 10px;
    }

    .sandbox-header button {
      padding: 6px 12px;
      background: #1e293b;
      border: 1px solid #334155;
      border-radius: 6px;
      color: white;
      cursor: pointer;
      font-size: 14px;
    }

    /* iframe は残り全体を使用 */
    .sandbox-frame {
      flex: 1;
      border: none;
      width: 100%;
      height: 100%;
    }

    @media (max-width: 768px) {
      .app {
        grid-template-columns: 1fr; /* 1カラムに */
        grid-template-rows: auto auto;
      }

      .editors {
        flex-direction: column; /* HTMLとCSSを縦並び */
      }

      textarea {
        min-height: 180px; /* スマホ向けに少し小さく */
      }

      .right {
        order: 1; /* 下に表示 */
      }

      .left {
        order: 2; /* 上に表示 */
      }

      input[type=text] {
        width: 100%;
      }

      button {
        flex: 1;
        width: 100%;
      }

      .controls {
        flex-wrap: wrap;
        flex-direction: column;
        align-items: stretch;
      }

      .note {
        font-size: 12px;
      }

      .row{
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: nowrap; /* ← 折り返さない */
      }

      #gptPrompt {
        flex: 1; /* ← 入力欄が余ったスペースを使う */
        min-width: 70%; /* ← スマホでも無理に広がらない */
      }

      #gptBtn {
        flex-shrink: 0; /* ← ボタン幅を維持して折り返さない */
        white-space: nowrap; /* ← ボタン文字を改行させない */
      }

      iframe{
        width:100%;
        height:600px;
      }

      .fullscreen-editor button.close-btn {
         flex:0;
    }
}
  </style>
</head>
<body>
  <div class="app">
    <div class="left">
      <div class="row">
        <input id="gptPrompt" type="text" placeholder="ChatGPTに依頼する内容を入力" style="flex:1" />
        <button id="gptBtn">ChatGPTで生成</button>
      </div>

      <div class="editors">
        <textarea id="htmlEditor" placeholder="HTML をここに書いてください">&lt;h1&gt;Hello world&lt;/h1&gt;
          &lt;p&gt;これは簡易エディタのプレビューです。&lt;/p&gt;</textarea>
          <textarea id="cssEditor" placeholder="CSS をここに書いてください">body{font-family:system-ui, -apple-system, 'Segoe UI', Roboto, 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif;padding:20px}
            h1{color:#0b5}
          </textarea>
        </div>
        
        <div class="tabs">
          <div class="tab">HTML View</div>
          <div class="tab">CSS View</div>
        </div>

      <div class="row controls">
        <button id="renderBtn">レンダー</button>
        <button id="undoBtn">戻る（Undo）</button>
        <button id="redoBtn">やり直し（Redo）</button>
        <button id="saveLocalBtn">ローカルに保存</button>
        <button id="downloadBtn">HTMLとしてダウンロード</button>
        <div style="flex:1"></div>
        <span class="note">ショートカット: Ctrl/Cmd+S 保存 • Ctrl/Cmd+Z Undo</span>
      </div>

      <div class="row controls">
        <input id="saveName" type="text" placeholder="保存名を入力（省略可）" />
        <button id="saveToListBtn">スナップショット保存</button>
      </div>

      <div>
        <div class="note">保存一覧（ローカル）</div>
        <div id="saveList" class="save-list"></div>
      </div>
    </div>

    <div class="right">
      <div class="row">
       <button id="openNewTab">プレビュー</button>
        <div id="sandboxContainer" class="hidden">
          <div class="sandbox-header">
            <button id="closeSandbox">閉じる</button>
          </div>
          <iframe id="sandboxFrame" sandbox="allow-same-origin" class="sandbox-frame"></iframe>
        </div>
      </div>
      <div class="iframe-wrap">
        <iframe id="preview" sandbox="allow-scripts allow-forms"></iframe>
      </div>
    </div>

  </div>

  <script>
    const apiEndpoint = '/api';

    // Elements
    const htmlEditor = document.getElementById('htmlEditor');
    const cssEditor = document.getElementById('cssEditor');
    const preview = document.getElementById('preview');
    const renderBtn = document.getElementById('renderBtn');
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');
    const saveLocalBtn = document.getElementById('saveLocalBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const saveToListBtn = document.getElementById('saveToListBtn');
    const saveList = document.getElementById('saveList');
    const saveName = document.getElementById('saveName');
    const openNewTab = document.getElementById('openNewTab');
    const gptPrompt = document.getElementById('gptPrompt');
    const gptBtn = document.getElementById('gptBtn');
    const tabs = document.querySelectorAll('.tabs .tab');

    const sandboxContainer = document.getElementById("sandboxContainer");
    const sandboxFrame = document.getElementById("sandboxFrame");
    const closeSandbox = document.getElementById("closeSandbox");

    openNewTab.addEventListener('click', () => {
      const content = `
        <!doctype html>
        <html>
          <head>
            <meta charset="utf-8">
            <style>${cssEditor.value}</style>
          </head>
          <body>${htmlEditor.value}</body>
        </html>`;

      // iframe に安全に書き込み
      sandboxFrame.srcdoc = content;

      // 表示
      sandboxContainer.classList.remove("hidden");
    });

    closeSandbox.addEventListener('click', () => {
      sandboxContainer.classList.add("hidden");
      sandboxFrame.srcdoc = ""; // 中身をクリア
    });

    tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        const isHTML = tab.textContent === 'HTML';
        const targetEditor = isHTML ? htmlEditor : cssEditor;

        // 全画面コンテナを作成
        const fullscreen = document.createElement('div');
        fullscreen.classList.add('fullscreen-editor');

        // 閉じるボタン
        const closeBtn = document.createElement('button');
        closeBtn.textContent = `${tab.textContent}閉じる ✕`;
        closeBtn.classList.add('close-btn');

        // テキストエリアをクローンして配置
        const clone = targetEditor.cloneNode(true);

        fullscreen.appendChild(closeBtn);
        fullscreen.appendChild(clone);
        document.body.appendChild(fullscreen);

        // 閉じる処理
        closeBtn.addEventListener('click', () => {
          document.body.removeChild(fullscreen);

          // 編集内容を反映（元のtextareaにコピー）
          targetEditor.value = clone.value;
        });
      });
    });


    // History for undo/redo
    const MAX_HISTORY = 80;
    let history = [];
    let historyIndex = -1;
    let typingTimer = null;

    gptBtn.addEventListener('click', async () => {
      const prompt = gptPrompt.value.trim();
      if (!prompt) return alert("プロンプトを入力してください");

      try {
        gptBtn.disabled = true;
        gptBtn.textContent = "生成中...";

        const res = await fetch(apiEndpoint, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ "message": prompt, "html": htmlEditor.value, "css": cssEditor.value })
        });

        const data = await res.json();
        const reply = data.reply;
        if (!reply) throw new Error("ChatGPTの返答が空です");
        
        // body と style を抽出
        const bodyMatch = reply.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
        const styleMatch = reply.match(/<style[^>]*>([\s\S]*?)<\/style>/i);
        if (!bodyMatch && !styleMatch) {
          throw new Error("ChatGPTの返答に<body>または<style>が見つかりません。");
        }
        // ChatGPTの出力をエディタに反映
        if(bodyMatch) htmlEditor.value = bodyMatch[1].trim();
        if(styleMatch) cssEditor.value = styleMatch[1].trim();
        pushHistory();
        renderPreview();
      } catch (err) {
        alert("リクエスト失敗: " + err.message);
      } finally {
        gptBtn.disabled = false;
        gptBtn.textContent = "ChatGPTで生成";
      }
    });

    function pushHistory() {
      const snapshot = { html: htmlEditor.value, css: cssEditor.value, time: Date.now() };
      // If we're not at the end, drop forward history
      if (historyIndex < history.length - 1) history = history.slice(0, historyIndex + 1);
      history.push(snapshot);
      if (history.length > MAX_HISTORY) history.shift();
      historyIndex = history.length - 1;
      updateUndoRedoButtons();
      saveWorkspaceToLocal();
    }

    function updateUndoRedoButtons(){
      undoBtn.disabled = historyIndex <= 0;
      redoBtn.disabled = historyIndex >= history.length - 1;
    }

    function applySnapshot(idx){
      if (idx < 0 || idx >= history.length) return;
      const s = history[idx];
      htmlEditor.value = s.html;
      cssEditor.value = s.css;
      historyIndex = idx;
      renderPreview();
      saveWorkspaceToLocal();
      updateUndoRedoButtons();
    }

    // debounce pushHistory
    function schedulePushHistory(){
      if (typingTimer) clearTimeout(typingTimer);
      typingTimer = setTimeout(() => { pushHistory(); }, 400);
    }

    // Render iframe using srcdoc
    function renderPreview(){
      const doc = `<!doctype html><html><head><meta charset="utf-8"><style>${cssEditor.value}</style></head><body>${htmlEditor.value}</body></html>`;
      // Use srcdoc for simplicity
      preview.srcdoc = doc;
    }

    // localStorage keys
    const WORKSPACE_KEY = 'mini-editor-workspace-v1';
    const SAVES_KEY = 'mini-editor-saves-v1';

    function saveWorkspaceToLocal(){
      const obj = { html: htmlEditor.value, css: cssEditor.value, time: Date.now() };
      try{ localStorage.setItem(WORKSPACE_KEY, JSON.stringify(obj)); }catch(e){console.warn('localStorage set failed', e)}
    }

    function loadWorkspaceFromLocal(){
      try{
        const raw = localStorage.getItem(WORKSPACE_KEY);
        if (raw){
          const obj = JSON.parse(raw);
          htmlEditor.value = obj.html || htmlEditor.value;
          cssEditor.value = obj.css || cssEditor.value;
        }
      }catch(e){console.warn('local load failed', e)}
    }

    // Saves list (snapshots)
    function loadSaves(){
      try{
        const raw = localStorage.getItem(SAVES_KEY);
        return raw ? JSON.parse(raw) : [];
      }catch(e){return[]}
    }
    function storeSaves(arr){
      try{ localStorage.setItem(SAVES_KEY, JSON.stringify(arr)); }catch(e){console.warn('save list store failed', e)}
    }

    function refreshSaveList(){
      const arr = loadSaves();
      saveList.innerHTML = '';
      if (!arr.length) { saveList.innerHTML = '<div class="note">保存はまだありません</div>'; return; }
      arr.slice().reverse().forEach((s, i)=>{
        const idx = arr.length - 1 - i; // original index
        const el = document.createElement('div'); el.className = 'save-item';
        const left = document.createElement('div'); left.innerHTML = `<div style="font-size:13px">${escapeHtml(s.name||'無名')} <small class="note">・${new Date(s.time).toLocaleString()}</small></div>`;
        const right = document.createElement('div');
        const loadBtn = document.createElement('button'); loadBtn.textContent='読み込む'; loadBtn.onclick = ()=>{ if(confirm('読み込みますか？ 現在の作業は上書きされます。')){ htmlEditor.value = s.html; cssEditor.value = s.css; pushHistory(); renderPreview(); }};
        const delBtn = document.createElement('button'); delBtn.textContent='削除'; delBtn.className='ghost'; delBtn.onclick = ()=>{ if(confirm('削除してよいですか？')){ const a = loadSaves(); a.splice(idx,1); storeSaves(a); refreshSaveList(); }};
        right.appendChild(loadBtn); right.appendChild(delBtn);
        el.appendChild(left); el.appendChild(right);
        saveList.appendChild(el);
      })
    }

    function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

    // Save current as snapshot to saves list
    function saveSnapshot(){
      const arr = loadSaves();
      arr.push({ name: saveName.value || 'snapshot', html: htmlEditor.value, css: cssEditor.value, time: Date.now() });
      storeSaves(arr);
      refreshSaveList();
      saveName.value = '';
      alert('スナップショットを保存しました');
    }

    // Download as .html file
    function downloadHTML(){
      const content = `<!doctype html><html><head><meta charset="utf-8"><title>Export</title><style>${cssEditor.value}</style></head><body>${htmlEditor.value}</body></html>`;
      const blob = new Blob([content], { type: 'text/html' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = (saveName.value || 'export') + '.html';
      document.body.appendChild(a); a.click(); a.remove();
    }

    // Buttons
    renderBtn.addEventListener('click', ()=>{ pushHistory(); renderPreview(); });
    undoBtn.addEventListener('click', ()=>{ if(historyIndex>0) applySnapshot(historyIndex-1); });
    redoBtn.addEventListener('click', ()=>{ if(historyIndex < history.length-1) applySnapshot(historyIndex+1); });
    saveToListBtn.addEventListener('click', ()=>{ saveSnapshot(); });
    downloadBtn.addEventListener('click', ()=>{ downloadHTML(); });
    saveLocalBtn.addEventListener('click', ()=>{ saveWorkspaceToLocal(); alert('ワークスペースをローカルに保存しました'); });
   
    // Input handlers
    htmlEditor.addEventListener('input', ()=>{ schedulePushHistory(); renderPreview(); });
    cssEditor.addEventListener('input', ()=>{ schedulePushHistory(); renderPreview(); });

    // Keyboard shortcuts
    window.addEventListener('keydown', (ev)=>{
      const mac = navigator.platform.toUpperCase().includes('MAC');
      const meta = mac ? ev.metaKey : ev.ctrlKey;
      if (meta && ev.key.toLowerCase() === 's'){
        ev.preventDefault();
        saveWorkspaceToLocal();
        alert('保存しました (localStorage)');
      }
      // Provide Ctrl/Cmd+Shift+S to snapshot
      if (meta && ev.shiftKey && ev.key.toLowerCase() === 's'){
        ev.preventDefault(); saveSnapshot();
      }
    });

    // Initialize: load workspace and push initial history
    loadWorkspaceFromLocal();
    pushHistory();
    renderPreview();
    refreshSaveList();

  </script>
</body>
</html>