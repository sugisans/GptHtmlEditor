<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>GPT HTML/CSS Editor</title>
  <style>
    :root{--gap:10px;--pane-bg:#0f172a;--panel-bg:#0b1220;--muted:#bfc8d9}
    html,body{height:100%;margin:0;;background:#0b1220;font-family:Inter,ui-sans-serif,system-ui,Helvetica,Arial}
    .app{display:grid;grid-template-columns:1fr 520px;gap:var(--gap);height:100vh;padding:12px;color:white}
    .left{display:flex;flex-direction:column;gap:10px}
    .editors{display:flex;gap:8px}
    textarea{width:100%;min-height:500px;resize:both;background:var(--panel-bg);border:1px solid rgba(255,255,255,0.06);color:#e6eef8;padding:10px;border-radius:8px;font-family:Menlo,monospace;font-size:13px}
    .tabs{display:flex;gap:6px}
    .tab{padding:6px 10px;background:#071127;border-radius:6px;cursor:pointer;color:var(--muted)}
    .tab:hover{color:#e6eef8}
    .tab.active{background:#0d1a2b;color:white}
    .controls{display:flex;gap:8px;align-items:center}
    button{background:#062037;color:white;border:1px solid rgba(255,255,255,0.06);padding:8px 10px;border-radius:8px;cursor:pointer}
    button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06)}
    .right{display:flex;flex-direction:column;gap:8px}
    .iframe-wrap{flex:1;border-radius:8px;overflow:hidden;border:1px solid rgba(255,255,255,0.06)}
    iframe{width:100%;height:100%;border:0;background:white}
    .save-list{max-height:140px;overflow:auto;background:#071127;padding:8px;border-radius:8px}
    .save-item{display:flex;justify-content:space-between;padding:6px;border-radius:6px}
    .note{color:var(--muted);font-size:13px}
    .row{display:flex;gap:8px;align-items:center}
    #openNewTab{flex:1}

    #gptPrompt{
      flex:1;
      display: inline-block;
      padding:6px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.06);
      background:#071127;
      color:white;
      font-size: 100%;
      width: 100%;
      min-height:0;
      resize: none;
      -ms-overflow-style: none;
      scrollbar-width: none;
    }

    #gptPrompt::-webkit-scrollbar{
      display:none;
    } 
    
   .fullscreen-editor {
      position: fixed;
      inset: 0;
      background: #0b1220;
      display: flex;
      flex-direction: column;
      z-index: 9999;
      padding: 10px;
    }

    .fullscreen-header {
      display: flex;
      gap: 8px;
      align-items: center;
      margin-bottom: 8px;
    }

    .fullscreen-editor textarea {
      flex: 1;
      width: 100%;
      height: 100%;
      resize: none;
      font-family: Menlo, monospace;
      font-size: 14px;
      background: #1e293b;
      color: white;
      border: 1px solid #334155;
      border-radius: 8px;
      padding: 10px;
    }

     .fullscreen-editor div{
       color:#e6eef8;
       font-family: Menlo, monospace;
       font-weight:900;
       font-size: 16px;
       padding: 8px;
     }

    #sandboxContainer {
      position: fixed;
      inset: 0;
      background: #0f172a;
      display: flex;
      flex-direction: column;
      z-index: 9999;
    }

    #sandboxContainer.hidden {
      display: none;
    }

    .sandbox-header {
      display: flex;
      justify-content: flex-end;
      padding: 10px;
    }

    .sandbox-header button {
      padding: 6px 12px;
      background: #1e293b;
      border: 1px solid #334155;
      border-radius: 6px;
      color: white;
      cursor: pointer;
      font-size: 14px;
    }

    /* iframe は残り全体を使用 */
    .sandbox-frame {
      flex: 1;
      border: none;
      width: 100%;
      height: 100%;
    }

    #msg {
      position: fixed;
      top: 50%;
      left: 1%;
      width: 140px;
      border-radius: 20px;
      border: none;
      text-align: center;
      background-color: rgba(0, 0, 0, 0.6);
      color: #ffffff;
  }

    @media (max-width: 768px) {
      .app {
        grid-template-columns: 1fr; /* 1カラムに */
        grid-template-rows: auto auto;
      }

      .editors {
        flex-direction: column; /* HTMLとCSSを縦並び */
      }

      textarea {
        min-height: 180px; /* スマホ向けに少し小さく */
      }

      .right {
        order: 1; /* 下に表示 */
      }

      .left {
        order: 2; /* 上に表示 */
      }

      input[type=text] {
        width: 100%;
      }

      button {
        flex: 1;
        width: 100%;
      }

      .controls {
        flex-wrap: wrap;
        flex-direction: column;
        align-items: stretch;
      }

      .note {
        visibility: hidden;
      }

      .row{
        display: flex;
        gap: 8px;
        align-items: center;
        flex-wrap: nowrap; /* ← 折り返さない */
      }

      #gptPrompt {
        flex: 1; /* ← 入力欄が余ったスペースを使う */
        min-width: 70%; /* ← スマホでも無理に広がらない */
      }

      #gptBtn {
        flex-shrink: 0; /* ← ボタン幅を維持して折り返さない */
        white-space: nowrap; /* ← ボタン文字を改行させない */
      }

      iframe{
        width:100%;
        height:600px;
      }

}
  </style>
</head>
<body>
  <div class="app">
    <div class="left">
      <div class="row">
        <textarea id="gptPrompt" placeholder="ChatGPTに依頼する内容を入力" autocomplete="off" rows="1" wrap=”soft”></textarea>
        <button id="gptBtn">ChatGPTで生成</button>
      </div>

      <div class="editors">
        <textarea id="htmlEditor" placeholder="HTML をここに書いてください">&lt;h1&gt;Hello world&lt;/h1&gt;
          &lt;p&gt;これはエディタのプレビューです。&lt;/p&gt;
          &lt;p&gt;ChatGPTで生成する場合はプロンプトを送信してください。&lt;/p&gt;
        </textarea>
          <textarea id="cssEditor" placeholder="CSS をここに書いてください">body{font-family:system-ui, -apple-system, 'Segoe UI', Roboto, 'Hiragino Kaku Gothic ProN', 'Meiryo', sans-serif;padding:20px}
            h1{color:#0b5}
          </textarea>
        </div>
        
        <div class="tabs">
          <div class="tab">HTML Viewer</div>
          <div class="tab">CSS Viewer</div>
        </div>

       <div class="row controls">
         <span class="note">ショートカット: Ctrl/Cmd+S 保存 • Ctrl/Cmd+Z Undo</span>
       </div>

      <div class="row controls">
        <button id="renderBtn">レンダー</button>
        <button id="undoBtn">戻る（←）</button>
        <button id="redoBtn">やり直し（→）</button>
        <button id="saveLocalBtn">ローカルに保存</button>
        <button id="downloadBtn">HTMLとしてダウンロード</button>
        <button id="loadFileBtn">HTMLファイルを読み込む</button>
        <input id="fileInput" type="file" accept=".html,.htm" style="display:none" />
        <button id="deleteBtn">初期化</button>
      </div>

      <div class="row controls">
        <input id="saveName" type="text" placeholder="保存名を入力（省略可）" />
        <button id="saveToListBtn">スナップショット保存</button>
      </div>

      <div>
        <div class="note">保存一覧（ローカル）</div>
        <div id="saveList" class="save-list"></div>
      </div>
    </div>

    <div class="right">
      <div class="row">
       <button id="openNewTab">プレビュー</button>
        <div id="sandboxContainer" class="hidden">
          <div class="sandbox-header">
            <button id="closeSandbox">閉じる</button>
          </div>
          <iframe id="sandboxFrame" sandbox="allow-same-origin" class="sandbox-frame"></iframe>
        </div>
      </div>
      <div class="iframe-wrap">
        <iframe id="preview" sandbox="allow-scripts allow-forms"></iframe>
      </div>
    </div>

  </div>

  <script async>
    const apiEndpoint = '/api';

    // localStorage keys
    const WORKSPACE_KEY = 'mini-editor-workspace-v1';
    const SAVES_KEY = 'mini-editor-saves-v1';

     // History for undo/redo
    const MAX_HISTORY = 80;
    let history = [];
    let historyIndex = -1;
    let typingTimer = null;
    let messageTimer = true;

    // Elements
    const htmlEditor = document.getElementById('htmlEditor');
    const cssEditor = document.getElementById('cssEditor');
    const preview = document.getElementById('preview');
    const renderBtn = document.getElementById('renderBtn');
    const undoBtn = document.getElementById('undoBtn');
    const redoBtn = document.getElementById('redoBtn');
    const saveLocalBtn = document.getElementById('saveLocalBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const saveToListBtn = document.getElementById('saveToListBtn');
    const saveList = document.getElementById('saveList');
    const saveName = document.getElementById('saveName');
    const openNewTab = document.getElementById('openNewTab');
    const gptPrompt = document.getElementById('gptPrompt');
    const gptBtn = document.getElementById('gptBtn');
    const tabs = document.querySelectorAll('.tabs .tab');
    const sandboxContainer = document.getElementById("sandboxContainer");
    const sandboxFrame = document.getElementById("sandboxFrame");
    const closeSandbox = document.getElementById("closeSandbox");
    const loadFileBtn = document.getElementById('loadFileBtn');
    const fileInput = document.getElementById('fileInput');
    const deleteBtn = document.getElementById('deleteBtn');

    const defaultHTML = htmlEditor.value;
    const defaultCSS = cssEditor.value;

    const promptPadding = 6;
    const promptModify = promptPadding * 2;

    // Initialize: load workspace and push initial history
    loadWorkspaceFromLocal();
    pushHistory();
    renderPreview();
    refreshSaveList();
    
    gptPrompt.style.padding = promptPadding + "px";
    textarea_resize(gptPrompt, promptModify);
    gptPrompt.addEventListener('keyup', (e)=>{ textarea_resize(gptPrompt, promptModify); });
    
    // Buttons
    renderBtn.addEventListener('click', ()=>{ pushHistory(); messageViewer('更新しました (render)'); renderPreview(); });
    undoBtn.addEventListener('click', ()=>{ if(historyIndex>0) applySnapshot(historyIndex-1); });
    redoBtn.addEventListener('click', ()=>{ if(historyIndex < history.length-1) applySnapshot(historyIndex+1); });
    saveToListBtn.addEventListener('click', ()=>{ saveSnapshot(); });
    downloadBtn.addEventListener('click', ()=>{ downloadHTML(); });
    loadFileBtn.addEventListener('click', ()=>{fileInput.click();});
    fileInput.addEventListener('change', (event)=>{inputHTML(event.target.files);})
    deleteBtn.addEventListener('click', ()=>{deleteData()});
    saveLocalBtn.addEventListener('click', ()=>{ saveWorkspaceToLocal(); messageViewer('保存しました (localStorage)'); renderPreview(); });
    
    // Input handlers
    htmlEditor.addEventListener('input', ()=>{ schedulePushHistory(); });
    cssEditor.addEventListener('input', ()=>{ schedulePushHistory(); });

    document.body.addEventListener('dragover', (event) => {
        event.preventDefault();
        document.body.classList.add('dragover');
    });
    document.body.addEventListener('dragleave', (event) => {
        event.preventDefault();
        document.body.classList.remove('dragover');
    });
    document.body.addEventListener('drop', (event) => { 
        event.preventDefault();
        document.body.classList.remove('dragover');
        if (confirm("HTMLファイルを読み込みますか？")) {
          fileInput.files = event.dataTransfer.files;
          inputHTML(fileInput.files);
        }
    });

    // Keyboard shortcuts
    window.addEventListener('keydown', (ev)=>{
      const mac = navigator.platform.toUpperCase().includes('MAC');
      const meta = mac ? ev.metaKey : ev.ctrlKey;
      if (meta && ev.key.toLowerCase() === 's'){
        ev.preventDefault();
        saveWorkspaceToLocal();
        messageViewer('保存しました (localStorage)');
        renderPreview(); 
      }
      // Provide Ctrl/Cmd+Shift+S to snapshot
      if (meta && ev.shiftKey && ev.key.toLowerCase() === 's'){
        ev.preventDefault(); saveSnapshot();
      }
    });

    openNewTab.addEventListener('click', () => {
      let html = htmlEditor.value;
      let css = cssEditor.value;
      html = html.replace(/<a\b([^>]*)href=["'][^"']*["']([^>]*)>/gi, '<a$1href="/404"$2>');

      const content =`
        <!doctype html>
        <html>
          <head>
            <meta charset="utf-8">
            <style>${css}</style>
          </head>
          <body>
            ${html}
          </body>
        </html>`;

      // iframe に安全に書き込み
      sandboxFrame.srcdoc = content;

      // 表示
      sandboxContainer.classList.remove("hidden");
    });

    closeSandbox.addEventListener('click', () => {
      sandboxContainer.classList.add("hidden");
      sandboxFrame.srcdoc = ""; // 中身をクリア
    });

  tabs.forEach(tab => {
      tab.addEventListener('click', () => {
        const isHTML = tab.textContent.match(/^html/i);
        const targetEditor = isHTML ? htmlEditor : cssEditor;

        // 全画面コンテナを作成
        const fullscreen = document.createElement('div');
        fullscreen.classList.add('fullscreen-editor');

        // ヘッダーバー
        const header = document.createElement('div');
        header.classList.add('fullscreen-header');

        const title = document.createElement('div');
        title.textContent = tab.textContent;

        // 閉じるボタン
        const closeBtn = document.createElement('button');
        closeBtn.textContent = "閉じる ✕";
        closeBtn.classList.add('close-btn');

        // テキストエリアをクローン
        const clone = targetEditor.cloneNode(true);

        // 戻るボタン
        const undoBtnFs = document.createElement('button');
        undoBtnFs.textContent = "戻る";
        undoBtnFs.addEventListener("click", () => {
          clone.focus();
          document.execCommand("undo");
        });

        // やり直しボタン
        const redoBtnFs = document.createElement('button');
        redoBtnFs.textContent = "やり直し";
        redoBtnFs.addEventListener("click", () => {
          clone.focus();
          document.execCommand("redo");
        });

        // 保存ボタン（既存保存処理を利用）
        const saveBtnFs = document.createElement('button');
        saveBtnFs.textContent = "保存";
        saveBtnFs.addEventListener("click", () => {
          targetEditor.value = clone.value; // 反映してから保存処理
          saveLocalBtn.click();
        });

        // ボタンを並べる
        header.appendChild(undoBtnFs);
        header.appendChild(redoBtnFs);
        header.appendChild(saveBtnFs);
        header.appendChild(closeBtn);
        
        fullscreen.appendChild(title);
        fullscreen.appendChild(header);
        fullscreen.appendChild(clone);
        document.body.appendChild(fullscreen);

        // 閉じる処理
        closeBtn.addEventListener('click', () => {
          document.body.removeChild(fullscreen);
          targetEditor.value = clone.value; // 内容を反映
        });
      });
    });

    gptBtn.addEventListener('click', async () => {
      const prompt = gptPrompt.value.trim();
      if (!prompt) return alert("プロンプトを入力してください");

      try {
        gptBtn.disabled = true;
        gptBtn.textContent = "生成中...";

        const res = await fetch(apiEndpoint, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ "message": prompt, "html": htmlEditor.value, "css": cssEditor.value })
        });

        const data = await res.json();
        const reply = data.reply;
        if (!reply) throw new Error("ChatGPTの返答が空です");
        
        // body と style を抽出
        const bodyMatch = reply.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
        const styleMatch = reply.match(/<style[^>]*>([\s\S]*?)<\/style>/i);
        if (!bodyMatch && !styleMatch) {
          throw new Error("ChatGPTの返答に<body>または<style>が見つかりません。");
        }
        // ChatGPTの出力をエディタに反映
        if(bodyMatch) htmlEditor.value = bodyMatch[1].trim();
        if(styleMatch) cssEditor.value = styleMatch[1].trim();
        pushHistory();
        renderPreview();
        
        gptPrompt.value = "";
        textarea_resize(gptPrompt, promptModify);
      } catch (err) {
        alert("リクエスト失敗: " + err.message);
      } finally {
        gptBtn.disabled = false;
        gptBtn.textContent = "ChatGPTで生成";
      }
    });

  function saveWorkspaceToLocal(){
    const obj = { html: htmlEditor.value, css: cssEditor.value, time: Date.now() };
    try{ localStorage.setItem(WORKSPACE_KEY, JSON.stringify(obj)); }catch(e){console.warn('localStorage set failed', e)}
  }

  function loadWorkspaceFromLocal(){
    try{
      const raw = localStorage.getItem(WORKSPACE_KEY);
      if (raw){
        const obj = JSON.parse(raw);
        htmlEditor.value = obj.html || htmlEditor.value;
        cssEditor.value = obj.css || cssEditor.value;
      }
    }catch(e){console.warn('local load failed', e)}
  }

  // Saves list (snapshots)
  function loadSaves(){
    try{
      const raw = localStorage.getItem(SAVES_KEY);
      return raw ? JSON.parse(raw) : [];
    }catch(e){return[]}
  }
  function storeSaves(arr){
    try{ localStorage.setItem(SAVES_KEY, JSON.stringify(arr)); }catch(e){console.warn('save list store failed', e)}
  }

  function refreshSaveList(){
    const arr = loadSaves();
    saveList.innerHTML = '';
    if (!arr.length) { saveList.innerHTML = '<div class="note">保存はまだありません</div>'; return; }
    arr.slice().reverse().forEach((s, i)=>{
      const idx = arr.length - 1 - i; // original index
      const el = document.createElement('div'); el.className = 'save-item';
      const left = document.createElement('div'); left.innerHTML = `<div style="font-size:13px">${escapeHtml(s.name||'無名')} <small class="note">・${new Date(s.time).toLocaleString()}</small></div>`;
      const right = document.createElement('div');
      const loadBtn = document.createElement('button'); loadBtn.textContent='読み込む'; loadBtn.onclick = ()=>{ if(confirm('読み込みますか？ 現在の作業は上書きされます。')){ htmlEditor.value = s.html; cssEditor.value = s.css; pushHistory(); renderPreview(); }};
      const delBtn = document.createElement('button'); delBtn.textContent='削除'; delBtn.className='ghost'; delBtn.onclick = ()=>{ if(confirm('削除してよいですか？')){ const a = loadSaves(); a.splice(idx,1); storeSaves(a); refreshSaveList(); }};
      right.appendChild(loadBtn); right.appendChild(delBtn);
      el.appendChild(left); el.appendChild(right);
      saveList.appendChild(el);
    })
  }

  function escapeHtml(s){ return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }

  // Save current as snapshot to saves list
  function saveSnapshot(){
    const arr = loadSaves();
    arr.push({ name: saveName.value || 'snapshot', html: htmlEditor.value, css: cssEditor.value, time: Date.now() });
    storeSaves(arr);
    refreshSaveList();
    saveName.value = '';
    alert('スナップショットを保存しました');
  }

  // Download as .html file
  function downloadHTML(){
    const content = `<!doctype html><html><head><meta charset="utf-8"><title>Export</title><style>${cssEditor.value}</style></head><body>${htmlEditor.value}</body></html>`;
    const blob = new Blob([content], { type: 'text/html' });
    const a = document.createElement('a');
    a.href = URL.createObjectURL(blob);
    a.download = (saveName.value || 'export') + '.html';
    document.body.appendChild(a); a.click(); a.remove();
  }

  function inputHTML(data){
    const file = data[0];
    console.log(file);
      if (!file || file.type !== 'text/html') {
          return window.alert("ファイルが対応しておりません");
      }

      const reader = new FileReader();
      reader.onload = () => {
        let content = reader.result;

        // --- セキュリティ対策: <script> をすべて削除 ---
        content = content.replace(/<script[\s\S]*?<\/script>/gi, "");
        content = content.replace(/<script[^>]*src=["'][^"']*["'][^>]*><\/script>/gi, "");

        // HTML と CSS を抽出
        const bodyMatch = content.match(/<body[^>]*>([\s\S]*?)<\/body>/i);
        const styleMatch = content.match(/<style[^>]*>([\s\S]*?)<\/style>/i);

        if (bodyMatch) {
          htmlEditor.value = bodyMatch[1].trim();
        } else {
          htmlEditor.value = content; // bodyタグが無ければ全体をHTMLとする
        }

        if (styleMatch) {
          cssEditor.value = styleMatch[1].trim();
        } else {
          cssEditor.value = "";
        }

        // 履歴に保存してプレビュー更新
        pushHistory();
        renderPreview();
      };

    reader.readAsText(file, "utf-8");
  }

  function deleteData(){
      if (confirm("本当にすべての保存データを削除して初期化しますか？")) {
          sessionStorage.clear();
          localStorage.clear();
          history = [];
          historyIndex = -1;
          htmlEditor.value = defaultHTML || "";
          cssEditor.value = defaultCSS || ""
          preview.srcdoc = "<!DOCTYPE html><html><head><meta charset='UTF-8'></head><body></body></html>";
          messageViewer("初期化しました。");
          
          loadWorkspaceFromLocal();
          pushHistory();
          renderPreview();
          refreshSaveList();
      }
  }

  function pushHistory() {
    const snapshot = { html: htmlEditor.value, css: cssEditor.value, time: Date.now() };
    // If we're not at the end, drop forward history
    if (historyIndex < history.length - 1) history = history.slice(0, historyIndex + 1);
    history.push(snapshot);
    if (history.length > MAX_HISTORY) history.shift();
    historyIndex = history.length - 1;
    updateUndoRedoButtons();
    saveWorkspaceToLocal();
  }

  function updateUndoRedoButtons(){
    undoBtn.disabled = historyIndex <= 0;
    redoBtn.disabled = historyIndex >= history.length - 1;
  }

  function applySnapshot(idx){
    if (idx < 0 || idx >= history.length) return;
    const s = history[idx];
    htmlEditor.value = s.html;
    cssEditor.value = s.css;
    historyIndex = idx;
    renderPreview();
    saveWorkspaceToLocal();
    updateUndoRedoButtons();
  }

  // debounce pushHistory
  function schedulePushHistory(){
    if (typingTimer) clearTimeout(typingTimer);
    typingTimer = setTimeout(() => { pushHistory(); }, 400);
  }

  // Render iframe using srcdoc
  function renderPreview(){
    htmlEditor.value = htmlEditor.value.replace(/<script[\s\S]*?<\/script>/gi, "")
      .replace(/<script[^>]*src=["'][^"']*["'][^>]*><\/script>/gi, "");

    const doc = `
      <!doctype html>
      <html>
        <head>
          <meta charset="utf-8">
          <script>
            document.addEventListener("DOMContentLoaded", () => {
              document.querySelectorAll("a").forEach(a => {
                a.addEventListener("click", e => {
                  e.preventDefault();
                });
              });
            });
          <\/script>
          <style>${cssEditor.value}</style>
        </head>
        <body>
          ${htmlEditor.value}
          </body>
      </html>`;
      preview.srcdoc = doc;
  }

  function textarea_resize(id, num){
    setTimeout(() => {
        id.style.minHeight = 0;
        id.style.minHeight = (id.scrollHeight - num) + "px";
    }, 100);
  }

  function messageViewer(text, element) {
    let message = document.createElement('dialog');
    message.setAttribute('open', true);
    message.id = "msg";
    message.style.zIndex = 1;
    message.textContent = String(text) || "";
    if (!element) {
        element = document.body;
    }
    if (messageTimer) {
        element.appendChild(message);
        setTimeout(function() {
            element.removeChild(message);
            messageTimer = true;
        }, 1000);
    }
    messageTimer = false;
}

  </script>
</body>
</html>